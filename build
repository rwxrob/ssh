#!/usr/bin/bash

x.images () {
  x.client
  x.server
}

x.server () {
	podman build -t ssh-server testdata/ssh-server
}

x.client () {
	podman build -t ssh-client .
}

x.clean () {
  x.stop
	podman rmi ssh-server
}

x.start-ssh-server () {
  [[ -z "$1" ]] && echo "missing server number" && return 1
  podman run -d -p "222$1:22" --rm --name "ssh-server$1" \
    --hostname "ssh-server$1" ssh-server
}

x.stop-ssh-server () {
  [[ -z "$1" ]] && echo "missing server number" && return 1
  podman stop "ssh-server$1"
}

x.start-ssh-servers () {
  for i in {1..3}; do
    if [[ -z "$(podman ps -q --filter "name=ssh-server$i")" ]]; then
      x.start-ssh-server "$i"
    fi
  done
}

x.stop-ssh-servers () {
  for i in {1..3}; do
    x.stop-ssh-server "$i"
  done
}

x.check-ssh-servers () {
  [[ -z "$RUNONANY_TARGET" ]] && echo '$RUNONANY_TARGET' required && return 1
  for i in {1..3}; do
    podman run -it --rm ssh-client ssh "user@$RUNONANY_TARGET" -p "222$i" -o StrictHostKeyChecking=no -i /home/user/.ssh/user hostname
  done
}

x.watch-client-runonany () {
  [[ -z "$RUNONANY_TARGET" ]] && echo '$RUNONANY_TARGET' required && return 1
  podman run -it --rm -e RUNONANY_TARGET="$RUNONANY_TARGET" ssh-client
}

# --------------------- completion and delegation --------------------
#      `complete -C foo foo` > `source <(foo bloated_completion)`

while IFS= read -r line; do
  [[ $line =~ ^declare\ -f\ x\. ]] || continue
  COMMANDS+=( "${line##declare -f x.}" )
done < <(declare -F)
mapfile -t COMMANDS < \
  <(LC_COLLATE=C sort < <(printf "%s\n" "${COMMANDS[@]}"))

if [[ -n $COMP_LINE ]]; then
  line=${COMP_LINE#* }
   for c in "${COMMANDS[@]}"; do
    [[ ${c:0:${#line}} == "${line,,}" ]] && echo "$c"
  done
  exit
fi

for c in "${COMMANDS[@]}"; do
  if [[ $c == "$EXE" ]]; then
    "x.$EXE" "$@"
    exit $?
  fi
done

if [[ -n "$1" ]]; then
  declare CMD="$1"; shift
  for c in "${COMMANDS[@]}"; do
    declare cmd=$(command -v "x.$c")
    if [[ $c == "$CMD" && -n "$cmd" ]]; then
      "x.$CMD" "$@"
      exit $?
    fi
  done
fi
