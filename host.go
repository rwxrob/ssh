package ssh

import (
	"encoding/json"
	"io"
	"strings"

	"golang.org/x/crypto/ssh"
	"gopkg.in/yaml.v3"
)

// A Host represents a single host on the network that is hosting
// a secure shell server. A Host may be safely marshaled/unmarshaled
// to/from JSON and YAML.
type Host struct {

	// Network host name or IP address (only, required)
	Addr string

	// Complete line taken in the authorized_hosts format (optional)
	Auth string

	// all derived from Auth during Init
	netkey  ssh.PublicKey
	pubkey  ssh.PublicKey
	comment string
	options []string
}

// Netkey is an RFC 4234 (section 6.6) key generated by Init (or
// indirectly from NewHost). Note that although this is an ssh.PublicKey
// that the exact format is very different from other ssh.PublicKey
// values (such as Pubkey).
func (h Host) Netkey() ssh.PublicKey { return h.netkey }

// Pubkey is generated by Init (or indirectly from NewHost). It is
// suitable for use with ssh.FixedHostkey. Note this is different than
// other ssh.PublicKey formats (see comment for Netkey).
func (h Host) Pubkey() ssh.PublicKey { return h.pubkey }

// Comment is derived from the Auth line that would appear in the
// authorized_hosts file along with other data for this host (see Auth,
// Options()).
func (h Host) Comment() string { return h.comment }

// Options allowed in the authorized_hosts file (from Auth) for this
// given host.
func (h Host) Options() []string { return h.options }

// KeyCallback returns ssh.FixedHostKey(h.Pubkey()) if Auth is not nil.
// Otherwise, returns ssh.InsecureIgnoreHostKey().
func (h Host) KeyCallback() ssh.HostKeyCallback {
	if h.Auth != "" {
		return ssh.FixedHostKey(h.pubkey)
	}
	return ssh.InsecureIgnoreHostKey()
}

// Init populates the required internal fields from the available
// exported ones (Addr, Auth) and is called from NewHost. Remember to
// call Init after unmarshaling a new Host.
func (h *Host) Init() error {
	var err error

	h.netkey, h.comment, h.options, _, err = ssh.ParseAuthorizedKey([]byte(h.Auth))
	if err != nil {
		return err
	}

	// following required since h.netkey (also ssh.PublicKey) is in RFC
	// format (which fails for ssh.FixedHostKey)

	h.pubkey, err = ssh.ParsePublicKey(h.netkey.Marshal())
	if err != nil {
		return err
	}

	return nil
}

// JSON is a convenience method for marshaling as JSON string.
// Marshaling errors return a "null" string.
func (h Host) JSON() string {
	byt, err := json.Marshal(h)
	if byt == nil || err != nil {
		return "null"
	}
	return string(byt)
}

// YAML is a convenience method for marshaling as YAML string.
// Marshaling errors return a "null" string.
func (h Host) YAML() string {
	byt, err := yaml.Marshal(h)
	if byt == nil || err != nil {
		return "null"
	}
	return string(byt)
}

// The NewHost function creates, initializes, and returns a new Host
// suitable for use in SSH connections. The first argument is the host
// name or IP address or IP address to use (Addr) The optional auth
// (Auth) is assumed to match the known_hosts format (which can be taken
// directly from most ~/.ssh/known_hosts files). If the auth is not an
// empty string then the assignment of the remaining related internal
// fields is done (Netkey(), Pubkey(), Comments(), Options()).
func NewHost(addr, auth string) (*Host, error) {
	h := new(Host)
	h.Addr = addr
	if len(auth) == 0 {
		return h, nil
	}
	h.Auth = strings.TrimSpace(auth)
	return h, h.Init()
}

// NewHostFromYAML reads the Name and Key from YAML instead of passing.
// See NewHost. ReadAll is used.
func NewHostFromYAML(r io.Reader) (*Host, error) {
	h := new(Host)
	byt, err := io.ReadAll(r)
	if err != nil {
		return nil, err
	}
	err = yaml.Unmarshal(byt, h)
	if err != nil {
		return nil, err
	}
	return h, h.Init()
}

// NewHostFromJSON reads the Name and Key from JSON instead of passing.
// See NewHost. ReadAll is used.
func NewHostFromJSON(r io.Reader) (*Host, error) {
	h := new(Host)
	byt, err := io.ReadAll(r)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(byt, h)
	if err != nil {
		return nil, err
	}
	return h, h.Init()
}
